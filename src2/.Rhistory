qqnorm(income); qqline(income)
hist(income) #symmetrisch, eerder uniform, misschien twee groepen
boxplot(log10(income))
qqnorm(log10(income)); qqline(log10(income))
hist(log10(income)) # geen verbetering
summary(powerTransform(income))
shapiro.test(log10(income))
summary(powerTransform(prestige))
par(mfrow=c(2,3)) # hoofdwet statistiek, kijk naar de data
boxplot(prestige)
qqnorm(prestige); qqline(prestige)
hist(prestige) #symmetrisch, eerder uniform, misschien twee groepen
boxplot(log10(prestige))
qqnorm(log10(prestige)); qqline(log10(prestige))
hist(log10(prestige)) # geen verbetering
shapiro.test(log10(prestige))
summary(powerTransform(prestige), 1/2)
summary(powerTransform(prestige), 1/3)
testTransform(powerTransform(prestige), 1/2)
testTransform(powerTransform(prestige), 1/3)
summary(powerTransform(women))
summary(powerTransform(women-1))
summary(powerTransform(women+0.1))
par(mfrow=c(2,3)) # hoofdwet statistiek, kijk naar de data
boxplot(women+0.1)
qqnorm(women+0.1); qqline(women+0.1)
hist(women+0.1) #symmetrisch, eerder uniform, misschien twee groepen
boxplot(log10(women+0.1))
qqnorm(log10(women+0.1)); qqline(log10(women+0.1))
hist(log10(women+0.1)) # geen verbetering
shapiro.test(log10(women+0.1))
summary(powerTransform(women))
par(mfrow=c(2,3)) # hoofdwet statistiek, kijk naar de data
boxplot(women)
qqnorm(women); qqline(women)
hist(women) #symmetrisch, eerder uniform, misschien twee groepen
boxplot(logit(women))
qqnorm(logit(women)); qqline(logit(women))
hist(logit(women)) # geen verbetering
shapiro.test(logit(women))
library(faraway)
install.packages(faraway)
install.packages('faraway')
par(mfrow=c(1,1))
library(faraway)
attach(strongx); head(strongx)
cross.lm = lm(crossx-energy)
summary(cross.lm)
plot(crossx-energy); abline(cross.lm, col="red")
par(mfrow=c(1,1))
library(faraway)
attach(strongx); head(strongx)
cross.lm = lm(crossx-energy)
summary(cross.lm)
plot(crossx-energy); abline(cross.lm, col="red")
cross.lm = lm(crossx-energy)
cross.lm = lm(crossx~energy)
summary(cross.lm)
plot(crossx-energy); abline(cross.lm, col="red")
View(cross.lm)
library(car)
attach(Prestige)
Y = prestige
X1 = education
X2 = log10(income)
X3 = women
? lm
prestige.0 = lm(Y)
prestige.1 = lm(Y~X1)
prestige.2 = lm(Y~X2)
prestige.12 = lm(Y~X1+X2)
prestige.123 = lm(Y~X1+X2+X3)
prestige.321 = lm(Y~X3+X2+X1)
prestige.0 = lm(Y~)
prestige.0 = lm(Y~1)
summary(prestige.123)
prestige.123$rank
# waarde
o = (prestige.123$coefficients[3,1] - 25)/ prestige.123$coefficients[3,2]
# waarde
o = (summary(prestige.123)$coefficients[3,1] - 25)/ summary(prestige.123)$coefficients[3,2]
length(Y)
prestige.1
prestige.1$df.residual
prestige.123$df.residual
indTest <- function(mod, let = 0){
o = (summary(mod)$coefficients[3,1] - let)/ summary(mod)$coefficients[3,2]
o
2*(1-pt(abs(t2),mod$df.residual))
return(2*(1-pt(abs(t2),mod$df.residual)))
}
indTest(prestige.123)
indTest <- function(mod, let = 0){
o = (summary(mod)$coefficients[3,1] - let)/ summary(mod)$coefficients[3,2]
o
2*(1-pt(abs(t2),mod$df.residual))
return(2*(1-pt(abs(o),mod$df.residual)))
}
indTest(prestige.123)
indTest <- function(mod, let = 0){
o = (summary(mod)$coefficients[3,1] - let)/ summary(mod)$coefficients[3,2]
o
2*(1-pt(abs(o),mod$df.residual))
return(2*(1-pt(abs(o),mod$df.residual)))
}
indTest(prestige.123)
indTest(prestige.2, 25)
indTest <- function(mod, par, let = 0){
o = (summary(mod)$coefficients[par,1] - let)/ summary(mod)$coefficients[par,2]
o
2*(1-pt(abs(o),mod$df.residual))
return(2*(1-pt(abs(o),mod$df.residual)))
}
indTest <- function(mod, par, let = 0){
o = (summary(mod)$coefficients[par,1] - let)/ summary(mod)$coefficients[par,2]
o
2*(1-pt(abs(o),mod$df.residual))
return(2*(1-pt(abs(o),mod$df.residual)))
}
indTest(prestige.123, 3)
indTest(prestige.2, 2, 25)
indTest(prestige.123, 3, 25)
indTest(prestige.123, 3, 30)
### Individuele testen
###----------------------
### 1. t-statistiek en p-waarde bij coef van X2 in prestige.123
###----------------------
summary.123 = summary(prestige.123); summary.123
beta2 = summary.123$coefficients[3,1]; beta2
sb2 = summary.123$coefficients[3,2]; sb2
t = beta2/sb2; t
2*(1-pt(abs(t),98))
###----------------------
### 2. test de hypothesen dat H0: beta_2 = 25 in prestige.2 en in prestige.123
###----------------------
# in model prestige.123:
t2 = (beta2-25)/sb2; t2
2*(1-pt(abs(t2),98))
# in model prestige.2:
summary.2 = summary(prestige.2); summary.2
beta2 = summary.2$coefficients[2,1]; beta2
sb2 = summary.2$coefficients[2,2]; sb2
t = beta2/sb2; t
2*(1-pt(t,100))
# in model prestige.2:
summary.2 = summary(prestige.2); summary.2
beta2 = summary.2$coefficients[2,1]; beta2
sb2 = summary.2$coefficients[2,2]; sb2
t = beta2/sb2; t
2*(1-pt(t,100))
summary(prestige.2)
summary.123
beta = summary.123$coefficients[c(2,4),1]; beta
sb = summary.123$coefficients[c(2,4),2]; sb
beta0 = c(4.5,0.1)
t = (beta-beta0)/sb; t
p = 2*(1-pt(abs(t),98)); p
p.adjust(p,method='bonferroni')
### Grafische voorstelling van betrouwbaarheidsgebieden
plot(c(2.5,5),c(-.05,.15),type='n',xlab='beta1',ylab='beta3')
points(c(beta[1],beta0[1]),c(beta[2],beta0[2]),col=c('red','blue'),pch=16)
BI = confint(prestige.123)
abline(v=BI[2,],col='red',lty="dashed")
abline(h=BI[4,],col='red',lty="dashed")
# univariate betrouwbaarheidsintervallen: de simultane uitspraak "het koppel (beta1,beta3) verschilt significant van (4.5,0.1)" op basis van deze grenzen, resulteert in een lagere betrouwbaarheid dan de beoogde 95%!
BIcor = confint(prestige.123, level=1-.05/2) # Bonferroni-correctie
abline(v=BIcor[2,],col='red')
abline(h=BIcor[4,],col='red')
### Kwadratensommen en determinatiecoefficient
###----------------------
### 4. Bereken de (aangepaste) determinatieco?ffici?nt op basis van anova op prestige.123
###----------------------
summary.123
anova(prestige.123)
attributes(anova(prestige.123))
SSE = anova(prestige.123)$"Sum Sq"[4]; SSE
SST = sum(anova(prestige.123)$"Sum Sq"); SST
rsq = 1-SSE/SST; rsq
abs(rsq-summary.123$r.squared)
dim(prestige.123$model)
rsqadj = 1-(SSE/(102-4))/(SST/(102-1)); rsqadj
abs(rsqadj-summary.123$adj.r.squared)
### Kwadratensommen en determinatiecoefficient
###----------------------
### 4. Bereken de (aangepaste) determinatieco?ffici?nt op basis van anova op prestige.123
###----------------------
summary.123
###----------------------
### 7.
###----------------------
prestige.12333 = lm(prestige~education+log10(income)+women+I(women**2)+I(women**3))
summary(prestige.12333)
anova(prestige.12,prestige.12333)
###########################################################
#################   Project src   #########################
###########################################################
library(car)
###########################################################
###############   Load and format data   ##################
###########################################################
# set wd
wd = dirname(rstudioapi::getActiveDocumentContext()$path); wd
setwd(wd)
# TODO als je kijkt op see data vissualy hebben we te veel rows...
# eerst alle data apart inlezen van Gent, Antwerpen en Brussel
gent = read.csv("listingsGhent16_04_2019.csv", header = TRUE, sep = ",", dec = ".")
gent$city = "Gent"
antwerpen = read.csv("listingsAntwerp20_04_2019.csv", header = TRUE, sep = ",", dec = ".")
antwerpen$city = "Antwerpen"
brussel = read.csv("listingsBrussels13_04_2019.csv", header = TRUE, sep = ",", dec = ".")
brussel$city = "Brussel"
# dataframes samenvoegen
airbnb = rbind(gent, antwerpen, brussel)
# test of dat alle rows van de drie data frames in de nieuwe dataframe zitten
#   naive test, enkel op aantal rijen gebaseerd
nrow(airbnb) == (nrow(gent) + nrow(antwerpen) + nrow(brussel))
names(airbnb[airbnb$city == "Gent",]) ; names(gent)
nrow(airbnb[airbnb$city == "Gent",]) ; nrow(gent)
comp = airbnb[airbnb$city == "Gent",]
head(comp); head(gent)
attributes(airbnb)$names
# price == 0 -> NA
airbnb$price[airbnb$price == 0] = NA
# minimum_nights > 365 -> NA
airbnb$minimum_nights[airbnb$minimum_nights > 365] = NA
# Full == verhuurd == 0 dagen vrij
airbnb$full = FALSE
airbnb$full[airbnb$availability_365 == 0] = TRUE
airbnb$last_review[airbnb$last_review == ""] = NA
airbnb$last_review = as.Date(airbnb$last_review)
# TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# last_review aanpassen brussel
airbnb$date_compiled = as.Date("2019-04-13")
datum = as.Date("2019-04-13");
airbnb$date_compiled[airbnb$city == "Brussel"] = as.Date(datum)
# last_review aanpassen Gent
datum = "2019-04-16"
airbnb$date_compiled[airbnb$city == "Gent"] = as.Date(datum)
# last_review aanpassen Antwerpen
datum = "2019-04-20";
airbnb$date_compiled[airbnb$city == "Antwerpen"] = as.Date(datum)
airbnb$last_review =  as.integer(airbnb$date_compiled) - as.integer(airbnb$last_review)
# airbnb$last_review[is.na(airbnb$last_review)] =
airbnb$date_compiled = NULL
allNA = TRUE
for (i in 1:nrow(airbnb)) {
if(!is.na(airbnb$neighbourhood_group)){
allNA = FALSE
}
}
allNA
# neighbourhood is all NA, so we drop it
airbnb$neighbourhood_group = NULL
attach(airbnb)
###########################################################
###############   Data Visualisation  #####################
###########################################################
names(airbnb)
for (i in 1:ncol(airbnb)) {
print(typeof(airbnb[1,i]))
}
svg(filename="visual.svg",
width=3*8,
height=6*8,
pointsize=12)
par(mfrow=c(6,3))
for (i in 1:ncol(airbnb)) {
if (names(airbnb)[i] != "name" && names(airbnb)[i] != "host_name")
{
if (is.numeric(airbnb[1,i]))
{
hist(airbnb[!is.na(airbnb[,i]) ,i], breaks =  "Sturges", main = names(airbnb)[i], xlab = names(airbnb)[i] )
}
else
{
barplot(table(airbnb[,i]), main = names(airbnb)[i], xlab = names(airbnb)[i])
}
}
else{
plot(1,1)
}
}
plot(1,1)
dev.off()
par(mfrow=c(1,1))
###########################################################
###############   Ligging en type verblijf   ##############
###########################################################
priceNoNa = price[!is.na(price)]
hist(price[price < 200], breaks = "Sturges")
# zeer zware rechterstaart
summary(powerTransform(price))
powerTransform(price)
### Type verblijf
table(airbnb$room_type) # bevat geen NA's
barplot(table(room_type))
boxplot(price[price <200]~room_type[price<200])
boxplot(price~room_type)
# shapiro test waardeloos omdat er teveel samples zijn, waardoor er te makkelijk
# de null hypothese verworpen wordt
qqnorm(price)
# price helemaal niet normaal
qqnorm(log10(price))
qqline(log10(price))
leveneTest(price~room_type)
#verschil in varianties
# hoofdstuk 14 & 15 zijn hier belangrijk voor
# gemiddelde huurprijs, dus waarschijnlijk enkel H15
# wat shit van H14 erop toegepast
rt.lm = lm(price~room_type)
summary(rt.lm)
# estimated mean price for roomtype
# suggested by this model:
# entire home = 88,544
# private = 52.921
# shared = 48.895
qqnorm(rt.lm$residuals)
qqnorm(lm(log10(price)~room_type)$residuals)
rt.an = aov(price~room_type)
summary(rt.an)
# iets aan rt is zeker signigicant
TukeyHSD(rt.an)
# significant verschill russen home/apt en de andere twee, maar geen significant verschil tussen private en shared
# cities
table(airbnb$city) # bevat geen NA's
barplot(table(city))
boxplot(price~city)
boxplot(price[price <200]~city[price<200])
TukeyHSD(aov(price~city))
# Antwerpen verschilt sterk van de rest, Gent en brussel niet verworpen
model.tables(aov(price~city), type="means")
model.tables(aov(price~city), type="effects")
TukeyHSD(aov(price~neighbourhood))
# bijna allemaal niet significant
summary(lm(price~neighbourhood))
# heel veel die niet belangrijk zijn
summary(aov(price~neighbourhood))
# signigicant verschil, maar de modelveronderstellingen zijn niet voldaan
# het lijkt erop dat dit niet er toe doet, en city meer dan genoeg is qua opsplitsing
# maar de vraagstelling wijst erop dat het waarschijnlijk wel zo is, help...
summary(lm(price~neighbourhood + room_type))
summary(aov(price~neighbourhood + room_type))
summary(aov(price~room_type + neighbourhood))
# shapiro test waardeloos omdat er teveel samples zijn, waardoor er te makkelijk
# de null hypothese verworpen wordt
qqnorm(price)
# price helemaal niet normaal
qqnorm(log10(price))
qqline(log10(price))
qqnorm(log10(log10(price)))
qqline(log10(price))
qqline(log10(log10(price)))
# estimated mean price for roomtype
# suggested by this model:
# entire home = 88,544
# private = 52.921
# shared = 48.895
mean(rt.lm$residuals)
# very small/ almost zere mean for residuals
cor(rt.lm$residuals)
e <- rt.lm$residuals
es <- e/(s*(1-h)^.5)
e <- residuals(rt.lm)
h <- rt.lm$hat
s <- rt.lm$sigma
es <- e/(s*(1-h)^.5)
es
h <- rt.lm$hat
e = residuals(rt.lm)
library(MASS)
es2 <- stdres(rt.lm)
es2
summary(es2)
qqnorm(es,ylab="Standardized residuals")
qqline(es)
# very small/ almost zere mean for residuals, maar dit is altijd zo voor LSE blijkbaar
# de normale quantile plot van de residuals maak je altijd van de gestandardiseerde waarden
e = residuals(rt.lm)
es = stdres(rt.lm)
qqnorm(es,ylab="Standardized residuals")
qqline(es)
plot(e,xlab="Index",ylab="Residuals")
plot(rt.lm) # first graph yields residuals versus fitted values
plot(es,xlab="Index",ylab="Standardized Residuals")
abline(h=-2.5,lty=2)
abline(h=2.5,lty=2)
es = stdres(rt.lm)
qqnorm(es,ylab="Standardized residuals")
qqline(es)
# wat shit van H14 erop toegepast
rt.lm = lm(price~log10(room_type))
plot(e,xlab="Index",ylab="Residuals")
# there does not seem to be correlation, some heavy outliners though
# checking without outliers to have a better view
plot(e[e<1000],xlab="Index",ylab="Residuals")
plot(e[e<200],xlab="Index",ylab="Residuals")
plot(rt.lm$fitted.values,e)
rt.lm$fitted.values
plot(es,xlab="Index",ylab="Standardized Residuals")
abline(h=-2.5,lty=2)
abline(h=2.5,lty=2)
leveneTest(price~room_type)
# very heavy right tail, not normal in its current form, skewed right
# TODO: hoe moet je dit oplossen
qqnorm(residuals(lm(sqrt(price~room_type))))
# very heavy right tail, not normal in its current form, skewed right
# TODO: hoe moet je dit oplossen
qqnorm(residuals(lm(sqrt(price)~room_type)))
qqline(residuals(lm(sqrt(price)~room_type)))
qqnorm(residuals(lm(log10(price)~room_type)))
qqline(residuals(lm(log10(price)~room_type)))
qqnorm(residuals(lm(log10(log10(price))~room_type)))
qqline(residuals(lm(log10(log10(price))~room_type)))
qqnorm(residuals(lm(log10(log10(log10(price)))~room_type)))
qqline(residuals(lm(log10(log10(log10(price)))~room_type)))
summary(powerTransform(e))
summary(powerTransform(e + min(e) + 0.0000001))
summary(powerTransform(e - min(e) + 0.0000001))
lambda = 0.09
qqnorm(residuals(lm(((power**lambda - 1)/lambda)~room_type)))
qqnorm(residuals(lm(((price**lambda - 1)/lambda)~room_type)))
lambda = 0.09
qqnorm(residuals(lm(((price**lambda - 1)/lambda)~room_type)))
qqline(residuals(lm(((price**lambda - 1)/lambda)~room_type)))
qqnorm(residuals(lm(log10(price)~room_type)))
qqline(residuals(lm(log10(price)~room_type)))
# TODO: probleem: heteroscedasticiteit
e=rt.lm$residuals
yhat=rt.lm$fitted.values
e.lm = lm(abs(e)~yhat); summary(e.lm)
w = 1/e.lm$fitted.values**2
leveneTest(log10(price)~room_type)
leveneTest(rt.lm)
leveneTest(rt.lm2)
# TODO: probleem: heteroscedasticiteit
e=rt.lm$residuals
yhat=rt.lm$fitted.values
e.lm = lm(abs(e)~yhat); summary(e.lm)
w = 1/e.lm$fitted.values**2
rt.lm2 = lm(y~x, weights=w); summary(lm.w)
rt.lm2 = lm(price~room_type, weights=w); summary(rt.lm2)
# TODO: probleem: heteroscedasticiteit
e=rt.lm$residuals
yhat=rt.lm$fitted.values
e.lm = lm(abs(e)~yhat); summary(e.lm)
w = 1/e.lm$fitted.values**2
rt.lm2 = lm(price~room_type, weights=w); summary(rt.lm2)
rt.lm2 = lm(price[!is.na(price)]~room_type[!is.na(price)], weights=w); summary(rt.lm2)
leveneTest(rt.lm2)
# TODO: probleem: heteroscedasticiteit
e=rt.lm$residuals
yhat=rt.lm$fitted.values
e.lm = lm(abs(e)~yhat); summary(e.lm)
w = 1/e.lm$fitted.values**2
rt.lm2 = lm(price[!is.na(price)]~room_type[!is.na(price)], weights=w); summary(rt.lm2)
leveneTest(rt.lm2)
leveneTest(rt.lm)
summary(rt.lm)
summary(rt.lm2)
qqnorm(residuals(lm(log10(price)~room_type)))
qqnorm(residuals(lm(((price**lambda - 1)/lambda)~room_type)))
# log 10 transformation shows best results
rt.lm = lm(log10(price)~room_type)
# log 10 transformation shows best results
rt.lm = lm(log10(price)~room_type)
summary(rt.lm)
# wat shit van H14 erop toegepast
rt.lm = lm(price~room_type)
summary(rt.lm)
# log 10 transformation shows best results
rt.lm = lm(log10(price)~room_type)
summary(rt.lm)
# 3th var more relevant
e = residuals(rt.lm)
es = stdres(rt.lm)
qqnorm(es,ylab="Standardized residuals")
qqline(es)
plot(e,xlab="Index",ylab="Residuals")
plot(rt.lm$fitted.values,e)
plot(es,xlab="Index",ylab="Standardized Residuals")
abline(h=-2.5,lty=2)
abline(h=2.5,lty=2)
leveneTest(log10(price)~room_type)
leveneTest(rt.lm)
leveneTest(rt.lm)
# TODO: probleem: heteroscedasticiteit
e=rt.lm$residuals
yhat=rt.lm$fitted.values
e.lm = lm(abs(e)~yhat); summary(e.lm)
w = 1/e.lm$fitted.values**2
rt.lm2 = lm(price[!is.na(price)]~room_type[!is.na(price)], weights=w); summary(rt.lm2)
leveneTest(rt.lm2)
qqnorm(rt.lm$residuals)
qqnorm(lm(log10(price)~room_type)$residuals)
rt.an = aov(log10(price)~room_type)
summary(rt.an)
TukeyHSD(rt.an)
leveneTest(rt.lm)
boxplot(table(price~room_type))
boxplot((log10(price)~room_type))
boxplot((price~room_type))
boxplot(price[price <200]~room_type[price<200])
boxplot((log10(price)~room_type))
boxplot(log10(price[log10(price) <2.5])~room_type[log10(price)<2.5])
boxplot(price[price <200]~room_type[price<200])
boxplot(price[price <155]~room_type[price<155])
boxplot(log10(price[log10(price) <2.5])~room_type[log10(price)<2.5])
table(airbnb$city) # bevat geen NA's
barplot(table(city))
boxplot(price~city)
boxplot(price[price <200]~city[price<200])
boxplot(price[price <155]~city[price<155])
